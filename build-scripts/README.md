# Скрипты fastlane 

Репозиторий хранит (пока что только) базовый файл с лейнами для Fastlane и является подмодулем основных актуальных проектов (клонируется и пуллится вместе с основным проектом). 

В базовом файле содержатся лейны, позволяющие пройти всю цепочку разработки - от развертывания сертификатов и до выгрузки в AppStore через сборку и публикацию бета-версий.

Каждый проект, имеющий ссылку на этот репозиторий, обязательно имеет корректно настроенный файл "../fastlane/project_settings.yml", актуальный файл "../fastlane/team_confidential.yml" и обязательно реализует следующие лейны в своем личном Fastfile:

## Uploading to AppStore Connect 

- [x] Сборка и выгрузка релизного билда в AppStore Connect
````ruby
lane :release do
  release_common
end
````

- [x] Сборка и выгрузка дебажного билда в AppStore Connect
````ruby
lane :beta_testflight do
  beta_testflight_common
end
````

## Uploading to App Center

- [x] Сборка и выгрузка релизного билда в App Center с публикацией во внутреннюю групппу
````ruby
lane :beta_release do
  beta_release_common
end
````

- [x] Сборка и выгрузка дебажного билда в AppStore Connect с публикацией во внутреннюю групппу
````ruby
lane :beta do
  beta_common
end
````

- [x] Сборка и выгрузка дебажного билда в AppStore Connect с публикацией в групппу для заказчиков
````ruby
lane :beta_customers do
  beta_customers_common
end
````

## Updating signings info

- [x] Загрузка сертификатов и профилей для подписи приложения из репозитория в GitLab
````ruby
lane :sync do |options|
  sync_common
end
````

- [x] Загрузка сертификатов и профилей для подписи приложения из репозитория в GitLab с обновлением на портале разработчиков
````ruby
lane :sync_force do |options|
  sync_force_common
end
````

- [x] Загрузка сертификатов и профилей для подписи приложения из репозитория в GitLab с обновлением на портале разработчиков и созданием сертификатов при необходимости
````ruby
lane :sync_force_certs do |options|
  sync_force_certs_common
end
````

## CI

- [x] Запускает сборку проекта на сиайке. Если фастлейну удается получить и релизные профиль и сертификат, то произведется так же и сборка релизного билда, но если не удастся - на успешность завершения шага это не повлияет. Для дебажной же сборки все обязано завершиться успехом, в противном случае шаг будет завершён ошибкой. (todo: надо бы использовать одни и те же профил и сертификаты)

````ruby
lane :ci_debug_build do |options|
  ci_build_common(isRelease: false)
end

lane :ci_release_build do |options|
  ci_build_common(isRelease: true)
end
````

- [x] Запускает тесты с генерацией junit (подхватывается гитлабом) и html (пока не подхватывается ничем) отчетов. Набор симуляторов описан в `common` - лейне.
````ruby
lane :ui_tests do
  ui_tests_common
end

lane :unit_tests do
  unit_tests_common
end
````

Как видно из кода - все эти лейны ссылаются на базовую реализацию из Fastfile в данном репозитории. При необходимости, вызов базовой реализации можно заменить на специфическую для конкретного проекта, но сугубо в рамках перечисленных лейнов. Это обусловлено удобством и является решением проблемы отсутствия перегрузки лейнов: разработчик, приходя на проект и независимо от специфических нюансов, всегда будет знать, какими лейнами он должен пользоваться. 


## Управление версионностью

Во всех лейнах выгрузки содержится вызов  ```update_version_number``` - единственный допустимый способ изменения версии приложения. Он позволяет выбрать обновлять ли версию приложения, или только версию сборки. В первом случае предоставляется выбор типа инкремента.

Предположим, версия приложения есть A.B.C, тогда:
- patch => C++
- minor => B++
- major => A++

После обновления версии и/или номера сборки создается коммит и тег и пушится в соответствующую типу выгрузки ветку в репозитории проекта (обычно это "beta"/"appstore").

Для проектов, базирующихся на генерируемом Xcodgen проекте, обновленные версии сохраняются и в соответствующий файл ".xcconfig".

## Оформление project_settings
Этот файл импортируется в ```commonFastfile```, который, в свою очередь, в тех или иных лейнах ссылается на каждый параметр из списка под спойлером. Следовательно, все они должны быть описаны для каждого конкретного проекта.

<details>
  <summary> Пример оформления файла параметров для проекта BaseApp </summary>
  
  
Bundle id главного таргета  
```app_bundle_id: "com.webant.baseapp" ```

Какая схема приложения будет использоваться для создания Beta и Release сборок приложения. По сути, является именем проекта  
```scheme: "BaseApp" ```

Схема для запуска UI-тестов в проекте.  
```ui_test_scheme: "UITests" ```

Схема для запуска Unit-тестов в проекте.  
```unit_test_scheme: "UnitTests" ```

Имя приложения в appcenter  
```app_name: "BaseApp-iOS" ```

AppleId под которым разрабатывается приложение. Необходимо для управления подписями и сертификатами  
```apple_user: "vdaron@gmail.com" ```

Если один AppleID аккаунт состоит в нескольких командах, то необходимо указать id команды, в которой идет разработка  
```team_id: "Z4Q83QXW57" ```

Для управления сертификатами разработчика. Если приложение использует AppleId аккаунт заказчика, то ветка должна называться согласно названию приложения. Если приложение публикуется под нашим аккаунтом, тогда значение должно быть "vdaron@gmail.com"  
```certificates_git_branch: "vdaron@gmail.com" ```

В какую ветку будет запушена версия после команды fastlane beta  
```beta_branch: "beta" ```

В какую ветку будет запушена версия после команды fastlane release  
```release_branch: "appstore" ```

В какую команду тестирования будут отправляться сборки для внутреннего тестирования  
```appcenter_inner_group: "Collaborators" ```

В какую команду тестирования будут отправляться сборки для тестирования заказчиком  
```appcenter_customer_group: "BaseApp-public" ```

Путь к файлу настройки проекта  
```plist_path: "BaseApp/Info.plist" ```

</details>

## Линтер

- [x] `linter/.swiftlint.yml` - родительский конфиг линтера, от которого должны наследоваться проектные
- [x] `linter/ci/index.html` - заглушка для несуществующих отчетов линтера
- [x] `linter/ci/lint_generate_report.sh` - запускает проверку проекта с помощью `swiftlint` и генерирует отчет о проверке
- [x] `linter/ci/lint_check_report.sh` - проверяет наличие отчета линтера и отправляет уведомление в mattermost при необходимости

## Вспомогательные скрипты

- [x] `utilities/install_utilities.sh` - производит установку необходимых инструментов
- [x] `utilities/launch_ios_simulator.sh` - убивает запущенные симуляторы и запускает указанный. Необходимость обусловлена неспособностью fastlane (у него лапки) запустить нужные симуляторы, если корневой процесс симулятора мертв

## Интеграция в проект

Для начала необходимо добавить сам подмодуль:  
```git submodule add git@gitlab.webant.ru:ios/buildscripts-ios.git build-scripts```  

Затем указать ветку для отслеживания:  
```git config -f .gitmodules submodule.build-scripts.branch master```  

Затем импортировать в fastfile проекта (добавить строку прям сверху) commonFastfile:  
```import "../build-scripts/fastlane/commonFastfile"```  

Привести fastfile к виду "ничего кроме лейнов, указанных в этом readme". [Пример](https://gitlab.webant.ru/ios/baseapp-ios/-/blob/master/fastlane/Fastfile) (Можно cmd+C cmd+v с полной заменой)  

Привести к требуемому виду project_settings. [Пример](https://gitlab.webant.ru/ios/baseapp-ios/-/blob/master/fastlane/project_settings.yml). **Обратить внимание на нейминг!**

Добровольно-принудительно:  
Добавить еще и этот [подмодуль](https://gitlab.webant.ru/ios/teamconfidential-ios)  в проект.

## Обновление подмодуля в проекте

Если что-то "прям беда не получается", можно перейти в папку подмодуля и сделать стандартный пулл, однако более верным является следующий вариант:

```git pull --recurse-submodules``` - для непосредственного обновления подмодулей  
```git config --global submodule.recurse true``` - для включения рекурсивного обновления по дефолту
